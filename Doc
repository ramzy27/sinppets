
import org.springframework.core.io.buffer.DataBuffer;
import org.springframework.core.io.buffer.DataBufferUtils;
import org.springframework.http.server.reactive.ServerHttpRequestDecorator;
import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.server.WebFilter;
import org.springframework.web.server.WebFilterChain;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.nio.charset.Charset;

public class BodyCachingWebFilter implements WebFilter {

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {
        return DataBufferUtils.join(exchange.getRequest().getBody())
                .flatMap(dataBuffer -> {
                    byte[] bytes = new byte[dataBuffer.readableByteCount()];
                    dataBuffer.read(bytes);
                    DataBufferUtils.release(dataBuffer);

                    String body = new String(bytes, Charset.forName("UTF-8"));
                    exchange.getAttributes().put("cachedRequestBody", body); // Store body as an attribute

                    // Reconstruct the request with cached body
                    ServerHttpRequestDecorator decoratedRequest = new ServerHttpRequestDecorator(exchange.getRequest()) {
                        @Override
                        public Flux<DataBuffer> getBody() {
                            return Flux.just(exchange.getResponse().bufferFactory().wrap(bytes));
                        }
                    };

                    return chain.filter(exchange.mutate().request(decoratedRequest).build());
                });
    }
}


@Override
public Mono<Void> writeWith(Publisher<? extends DataBuffer> body) {
    Mono<DataBuffer> modifiedBody = Mono.from(body)
        .flatMap(dataBuffer -> {
            try {
                log.info("Reading response body");
                String responseBody = StandardCharsets.UTF_8.decode(dataBuffer.asByteBuffer()).toString();

                log.info("Modifying response body");
                String modifiedResponse = modifyResponseBody(responseBody, exchange.getRequest().getHeaders().get(REQUEST_HEADER_ORIGINAL_HOST));

                byte[] bytes = modifiedResponse.getBytes(StandardCharsets.UTF_8);
                DataBufferUtils.release(dataBuffer);
                
                log.info("Creating new data buffer");
                return Mono.just(originalResponse.bufferFactory().wrap(bytes));
            } catch (Exception e) {
                log.error("Error during response modification", e);
                return Mono.error(e);
            }
        });

    return super.writeWith(modifiedBody)
        .doOnTerminate(() -> log.info("Response writing terminated"))
        .doOnError(error -> log.error("Error writing response", error));
}

To incorporate logging at each step and provide the complete `WebFilter` component, you can use `log.info` statements. Here's the complete revised code with logging:

```java
import org.springframework.core.io.buffer.DataBuffer;
import org.springframework.core.io.buffer.DataBufferUtils;
import org.springframework.http.server.reactive.ServerHttpResponse;
import org.springframework.http.server.reactive.ServerHttpResponseDecorator;
import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.server.WebFilter;
import org.springframework.web.server.WebFilterChain;
import reactor.core.publisher.Mono;
import reactor.core.publisher.Flux;
import org.reactivestreams.Publisher;

import java.nio.charset.StandardCharsets;
import java.util.List;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class MyWebFilter implements WebFilter {

    private static final Logger log = LoggerFactory.getLogger(MyWebFilter.class);
    private static final String SWAGGER_CONFIG_API_PATH = "/your-swagger-path";
    private static final String REQUEST_HEADER_ORIGINAL_HOST = "your-header";
    private static final String DYNAMIC_PLACEHOLDER = "your-placeholder";

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {
        log.info("Filtering request: {}", exchange.getRequest().getURI());
        if (exchange.getRequest().getURI().getPath().contains(SWAGGER_CONFIG_API_PATH)) {
            ServerHttpResponse originalResponse = exchange.getResponse();
            ServerHttpResponseDecorator decoratedResponse = new ServerHttpResponseDecorator(originalResponse) {
                @Override
                public Mono<Void> writeWith(Publisher<? extends DataBuffer> body) {
                    Mono<DataBuffer> modifiedBody = Mono.from(body)
                        .map(dataBuffer -> {
                            try {
                                log.info("Reading response body");
                                String responseBody = StandardCharsets.UTF_8.decode(dataBuffer.asByteBuffer()).toString();

                                log.info("Modifying response body");
                                String modifiedResponse = modifyResponseBody(responseBody, exchange.getRequest().getHeaders().get(REQUEST_HEADER_ORIGINAL_HOST));

                                byte[] bytes = modifiedResponse.getBytes(StandardCharsets.UTF_8);
                                return originalResponse.bufferFactory().wrap(bytes);
                            } finally {
                                log.info("Releasing data buffer");
                                DataBufferUtils.release(dataBuffer);
                            }
                        });

                    log.info("Writing modified response body");
                    return super.writeWith(modifiedBody);
                }
            };

            log.info("Continuing filter chain with decorated response");
            return chain.filter(exchange.mutate().response(decoratedResponse).build());
        }

        log.info("URI path does not contain Swagger config path, continuing filter chain normally");
        return chain.filter(exchange);
    }

    private String modifyResponseBody(String responseBody, List<String> originalHosts) {
        log.info("Modifying response body based on original hosts");
        if (originalHosts != null && !originalHosts.isEmpty()) {
            return responseBody.replace(DYNAMIC_PLACEHOLDER, originalHosts.get(0));
        }
        return responseBody;
    }
}
```

In this updated version, `log.info` statements are added at each major step to help with debugging and tracking the flow of the request and response. Make sure you have SLF4J and a logging implementation (like Logback) configured in your project to see these logs. Adjust the constants like `

pipeline {
    agent any

    stages {
        stage('Get Artifact Name') {
            steps {
                script {
                    // Construct the URL for metadata.xml
                    def metadataUrl = "${nexusRepoURL}/${groupId.replace('.', '/')}/${artifactId}/${version}/maven-metadata.xml"

                    // Download the metadata.xml file
                    sh "curl -o metadata.xml ${metadataUrl}"

                    // Parse the metadata.xml to get the latest snapshot version
                    def metadataXml = readFile('metadata.xml')
                    def matcher = metadataXml =~ /<value>(.+)<\/value>/
                    def latestSnapshotVersion = ''
                    if (matcher.matches()) {
                        latestSnapshotVersion = matcher.group(1)
                    }

                    // Construct the artifact filename
                    def artifactFileName = "${artifactId}-${latestSnapshotVersion}.jar" // Change the extension if needed

                    // Print the artifact name
                    echo "Latest artifact name: ${artifactFileName}"
                }
            }
        }
    }
}

@Override
    public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {
        if (exchange.getRequest().getURI().getPath().contains(SWAGGER_CONFIG_API_PATH)) {
            ServerHttpResponse originalResponse = exchange.getResponse();
            ServerHttpResponseDecorator decoratedResponse = new ServerHttpResponseDecorator(originalResponse) {
                @Override
                public Mono<Void> writeWith(Flux<? extends DataBuffer> body) {
                    Flux<DataBuffer> modifiedBody = body.map(dataBuffer -> {
                        // Read the dataBuffer into a String
                        String responseBody = StandardCharsets.UTF_8.decode(dataBuffer.asByteBuffer()).toString();
                        // Release the dataBuffer to prevent memory leaks
                        DataBufferUtils.release(dataBuffer);
                        
                        // Modify the responseBody as needed
                        String modifiedResponse = modifyResponseBody(responseBody, exchange.getRequest().getHeaders().get(REQUEST_HEADER_ORIGINAL_HOST));
                        
                        // Convert the modified response back into a DataBuffer
                        byte[] bytes = modifiedResponse.getBytes(StandardCharsets.UTF_8);
                        return originalResponse.bufferFactory().wrap(bytes);
                    });

                    // Write the modified body
                    return super.writeWith(modifiedBody);
                }
            };

            // Continue the filter chain with the decorated response
            return chain.filter(exchange.mutate().response(decoratedResponse).build());
        }

        // If the URI path does not contain the Swagger config path, continue the filter chain normally
        return chain.filter(exchange);
    }

    private String modifyResponseBody(String responseBody, List<String> originalHosts) {
        // Replace the dynamic placeholder with the original host from the request headers
        if (originalHosts != null && !originalHosts.isEmpty()) {
            return responseBody.replace(DYNAMIC_PLACEHOLDER, originalHosts.get(0));
        }
        return responseBody;
    }
}


